<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Hybrid AR.js + WebXR Anchor</title>
<script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ar.js@3.4.2/aframe/build/aframe-ar.min.js"></script>
<style>
html,body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; }
#ui { position:fixed; bottom:10px; left:10px; z-index:100; display:flex; gap:8px; }
.panel { background:rgba(0,0,0,0.6); color:#fff; padding:8px; border-radius:6px; font-family:sans-serif; min-width:220px; }
button { padding:6px 12px; border:none; border-radius:6px; background:#1e88e5; color:#fff; cursor:pointer; }
</style>
</head>
<body>

<div id="ui">
  <div class="panel" id="status">Camera not started.</div>
  <div class="panel"><button id="startCameraBtn">Start Camera</button></div>
  <div class="panel"><button id="startWebXRBtn" disabled>Start WebXR (Anchors)</button></div>
</div>

<a-scene id="scene" embedded vr-mode-ui="enabled: false" arjs="sourceType: webcam; debugUIEnabled: false; autoStart: false;">
  <a-marker id="marker" type="pattern" url="pattern-qr.patt">
    <a-entity id="markerModel" position="0 0 0">
      <a-box position="0 0.5 0" depth="0.02" height="0.4" width="0.4" color="orange" opacity="0.8"></a-box>
    </a-entity>
  </a-marker>
  <a-entity camera id="camera"></a-entity>
</a-scene>

<script>
const statusEl = document.getElementById('status');
const startCameraBtn = document.getElementById('startCameraBtn');
const startWebXRBtn = document.getElementById('startWebXRBtn');
const sceneEl = document.getElementById('scene');
const markerEl = document.getElementById('marker');
const markerModel = document.getElementById('markerModel');

let xrSession = null;
let xrRefSpace = null;
let anchor = null;
let anchorCreated = false;
let markerVisible = false;

// -------------------- CAMERA START --------------------
startCameraBtn.addEventListener('click', () => {
  statusEl.textContent = 'Starting camera...';
  sceneEl.components['arjs'].start();
  statusEl.textContent = 'Camera started! Waiting for marker detection.';
  startCameraBtn.disabled = true;
});

// -------------------- MARKER VISIBILITY --------------------
markerEl.addEventListener('markerFound', () => {
  markerVisible = true;
  statusEl.textContent = 'Marker found! You can now start WebXR.';
  startWebXRBtn.disabled = false;
});

markerEl.addEventListener('markerLost', () => {
  markerVisible = false;
  if (!anchorCreated) statusEl.textContent = 'Marker lost (no anchor yet). Move camera to re-detect.';
});

// -------------------- WEBXR ANCHOR --------------------
startWebXRBtn.addEventListener('click', async () => {
  startWebXRBtn.disabled = true;
  statusEl.textContent = 'Requesting WebXR session...';

  if (!navigator.xr) {
    statusEl.textContent = 'WebXR not available â€” fallback to marker only.';
    return;
  }

  try {
    xrSession = await navigator.xr.requestSession('immersive-ar', {
      optionalFeatures: ['local-floor', 'anchors', 'hit-test', 'dom-overlay'],
      domOverlay: { root: document.body }
    });
  } catch (err) {
    console.error('WebXR requestSession failed:', err);
    statusEl.textContent = 'WebXR session failed. Using marker-only.';
    return;
  }

  statusEl.textContent = 'WebXR session started. Waiting for marker & XR frame to create anchor.';

  // Create WebGL context compatible with XR
  const rendererCanvas = document.querySelector('canvas');
  const gl = rendererCanvas.getContext('webgl', { xrCompatible: true });
  await gl.makeXRCompatible();
  xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });
  xrRefSpace = await xrSession.requestReferenceSpace('local');

  xrSession.requestAnimationFrame(onXRFrame);

  xrSession.addEventListener('end', () => {
    statusEl.textContent = 'WebXR session ended.';
    xrSession = null;
    anchor = null;
    anchorCreated = false;
  });
});

// -------------------- XR FRAME --------------------
async function onXRFrame(time, xrFrame) {
  xrSession.requestAnimationFrame(onXRFrame);

  if (!markerVisible || !xrFrame || anchorCreated) return;

  try {
    // Get marker world matrix from A-Frame
    const m = markerModel.object3D.matrixWorld.clone();
    const { pos, quat } = matrixToPosQuat(m);

    // Convert to XR space
    const xrTransform = new XRRigidTransform({ x: pos.x, y: pos.y, z: pos.z },
                                             { x: quat.x, y: quat.y, z: quat.z, w: quat.w });

    if (typeof xrFrame.createAnchor === 'function') {
      anchor = await xrFrame.createAnchor(xrTransform, xrRefSpace);
      anchorCreated = true;
      statusEl.textContent = 'Anchor created! Object is now world-locked.';
    } else {
      statusEl.textContent = 'Anchor API not available. Marker-only rendering.';
    }
  } catch (err) {
    console.warn('XR anchor creation error:', err);
  }
}

// -------------------- UTILITY --------------------
function matrixToPosQuat(m) {
  const pos = new THREE.Vector3();
  const quat = new THREE.Quaternion();
  const scale = new THREE.Vector3();
  m.decompose(pos, quat, scale);
  return { pos, quat };
}

// -------------------- VISIBILITY SAFETY --------------------
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden' && xrSession) xrSession.end();
});
</script>

</body>
</html>
