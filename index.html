<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>QR Debug & Spawn (visual)</title>
  <style>
    html,body { height:100%; margin:0; background:#000; font-family: Arial, sans-serif; color:#fff; }
    #container { position:relative; width:100%; height:100vh; overflow:hidden; background:#111; }
    video#cam {
      position:absolute; left:0; top:0; width:100%; height:100%; object-fit:cover;
      -webkit-transform: scaleX(-1); transform: scaleX(-1); /* mirror for user-facing feel */
    }
    canvas#overlay {
      position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none;
    }
    #spawnImg {
      position:absolute; left:0; top:0; width:0; height:0;
      transform-origin: 0 0; pointer-events:none; will-change:transform, width, height, left, top;
      display:none; border:2px solid rgba(255,255,255,0.25);
    }
    #ui {
      position: absolute; left: 12px; top: 12px; z-index:20;
      background: rgba(0,0,0,0.45); padding:8px 12px; border-radius:8px;
    }
    #statusBox {
      position:absolute; left:50%; transform:translateX(-50%); bottom:18px; z-index:20;
      background: rgba(0,0,0,0.6); padding:8px 12px; border-radius:8px; font-size:15px;
    }
    button { font-size:14px; padding:6px 10px; border-radius:6px; border:none; cursor:pointer; }
  </style>
</head>
<body>
  <div id="container">
    <video id="cam" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
    <!-- this image will be spawned on top of the detected QR -->
    <img id="spawnImg" src="./new.jpg" alt="spawn"/>

    <div id="ui">
      <button id="startBtn">Start Camera</button>
      <button id="stopBtn" style="margin-left:8px">Stop</button>
      <div style="margin-top:8px; font-size:13px; color:#ddd">
        Tip: make a black/white QR ~100+px in frame, flatten and well-lit.
      </div>
    </div>

    <div id="statusBox">Idle</div>
  </div>

  <!-- jsQR fallback -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

  <script>
  (function(){
    const video = document.getElementById('cam');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusBox = document.getElementById('statusBox');
    const spawnImg = document.getElementById('spawnImg');

    let stream = null;
    let running = false;
    let detector = null; // BarcodeDetector if available

    // Resize overlay canvas to match displayed video size (CSS pixels)
    function resizeOverlay() {
      const rect = video.getBoundingClientRect();
      overlay.width = Math.floor(rect.width);
      overlay.height = Math.floor(rect.height);
      overlay.style.width = rect.width + 'px';
      overlay.style.height = rect.height + 'px';
    }

    // Map a point from intrinsic video pixels -> displayed CSS pixels used by overlay.
    // We'll draw using the display coordinate system (overlay canvas).
    function mapVideoPointToDisplay(px, py, vidW, vidH, dispW, dispH) {
      // We use object-fit: cover mapping (video fills the element and may be cropped).
      const videoRatio = vidW / vidH;
      const dispRatio = dispW / dispH;
      let srcW = vidW, srcH = vidH, srcX = 0, srcY = 0;
      if (videoRatio > dispRatio) {
        // crop left/right
        srcW = vidH * dispRatio;
        srcX = (vidW - srcW) / 2;
      } else {
        // crop top/bottom
        srcH = vidW / dispRatio;
        srcY = (vidH - srcH) / 2;
      }
      const nx = (px - srcX) / srcW; // 0..1 inside visible area
      const ny = (py - srcY) / srcH;
      return { x: nx * dispW, y: ny * dispH };
    }

    // Draw polygon & text on overlay
    function drawDetection(cornersDisplay, text) {
      ctx.clearRect(0,0,overlay.width, overlay.height);
      if (!cornersDisplay || cornersDisplay.length < 4) return;

      ctx.lineWidth = 4;
      ctx.strokeStyle = 'lime';
      ctx.beginPath();
      ctx.moveTo(cornersDisplay[0].x, cornersDisplay[0].y);
      for (let i=1;i<cornersDisplay.length;i++) ctx.lineTo(cornersDisplay[i].x, cornersDisplay[i].y);
      ctx.closePath();
      ctx.stroke();

      // draw small filled circles at corners
      ctx.fillStyle = 'rgba(0,255,0,0.9)';
      for (const p of cornersDisplay) ctx.fillRect(p.x-4, p.y-4, 8, 8);

      // draw text background
      ctx.font = '18px Arial';
      const textPadding = 6;
      const metrics = ctx.measureText(text);
      const textW = metrics.width;
      const tx = cornersDisplay[0].x;
      const ty = Math.max(20, cornersDisplay[0].y - 10);
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(tx - textPadding, ty - 18 - textPadding/2, textW + textPadding*2, 22 + textPadding/2);
      ctx.fillStyle = 'lime';
      ctx.fillText(text, tx, ty);
    }

    // Place spawn image over detected quad using top-left, top-right to compute angle.
    function placeSpawnImage(cornersDisplay, imageUrl) {
      // cornersDisplay in overlay canvas space
      const xs = cornersDisplay.map(p=>p.x), ys = cornersDisplay.map(p=>p.y);
      const minX = Math.min(...xs), minY = Math.min(...ys);
      const maxX = Math.max(...xs), maxY = Math.max(...ys);
      const width = maxX - minX, height = maxY - minY;

      // angle from top-left -> top-right
      const dx = cornersDisplay[1].x - cornersDisplay[0].x;
      const dy = cornersDisplay[1].y - cornersDisplay[0].y;
      const angleDeg = Math.atan2(dy, dx) * 180 / Math.PI;

      // set image source (if different)
      if (spawnImg.src.indexOf(imageUrl) === -1 && !spawnImg.dataset.loading) {
        spawnImg.dataset.loading = '1';
        spawnImg.onload = () => {
          delete spawnImg.dataset.loading;
          spawnImg.style.display = 'block';
        };
        spawnImg.onerror = () => {
          delete spawnImg.dataset.loading;
          statusBox.textContent = 'Spawn image failed to load';
        };
        spawnImg.src = imageUrl;
      } else {
        spawnImg.style.display = 'block';
      }

      // set size & position and rotation around top-left (transform-origin 0 0)
      spawnImg.style.left = minX + 'px';
      spawnImg.style.top = minY + 'px';
      spawnImg.style.width = width + 'px';
      spawnImg.style.height = height + 'px';
      spawnImg.style.transform = `rotate(${angleDeg}deg)`;
    }

    // Clear overlay and hide spawn
    function clearOverlay() {
      ctx.clearRect(0,0,overlay.width, overlay.height);
      spawnImg.style.display = 'none';
    }

    // Main detection loop (draws into a temporary canvas sized to video intrinsic pixels,
    // but maps results to overlay display coords)
    async function detectLoop() {
      if (!running) return;

      // video intrinsic size
      const vidW = video.videoWidth;
      const vidH = video.videoHeight;
      if (!vidW || !vidH) {
        requestAnimationFrame(detectLoop); return;
      }

      // create small temp canvas sized to intrinsic video
      const temp = document.createElement('canvas');
      temp.width = vidW; temp.height = vidH;
      const tctx = temp.getContext('2d');
      // draw current frame
      try {
        tctx.drawImage(video, 0, 0, vidW, vidH);
      } catch (e) {
        // some browsers may block drawImage if not ready; skip this frame
        requestAnimationFrame(detectLoop); return;
      }

      let qrText = null;
      let corners = null; // corners in video intrinsic pixels

      // try BarcodeDetector (gives cornerPoints or boundingBox)
      if (detector) {
        try {
          // Some implementations accept ImageBitmap for performance
          const bitmap = await createImageBitmap(temp);
          const detections = await detector.detect(bitmap);
          bitmap.close?.();
          if (detections && detections.length) {
            const d = detections[0];
            qrText = d.rawValue || d.rawData || (d.rawValue===undefined ? null : d.rawValue);
            // many implementations provide cornerPoints
            if (d.cornerPoints && d.cornerPoints.length >= 4) {
              corners = d.cornerPoints.map(p => ({ x: p.x, y: p.y }));
            } else if (d.boundingBox) {
              const bb = d.boundingBox;
              corners = [
                {x: bb.x, y: bb.y},
                {x: bb.x + bb.width, y: bb.y},
                {x: bb.x + bb.width, y: bb.y + bb.height},
                {x: bb.x, y: bb.y + bb.height}
              ];
            }
          }
        } catch (e) {
          // ignore barcode errors, will fallback to jsQR
          console.warn('BarcodeDetector error', e);
        }
      }

      // fallback to jsQR if needed
      if (!qrText) {
        const imageData = tctx.getImageData(0,0,temp.width,temp.height);
        const code = jsQR(imageData.data, imageData.width, imageData.height);
        if (code) {
          qrText = code.data;
          // code.location has corners as {x,y}
          corners = [
            code.location.topLeftCorner,
            code.location.topRightCorner,
            code.location.bottomRightCorner,
            code.location.bottomLeftCorner
          ];
        }
      }

      // map corners from video intrinsic -> display overlay coordinates
      if (corners && corners.length >= 4) {
        resizeOverlay(); // keep overlay in sync
        const rect = video.getBoundingClientRect();
        const dispW = overlay.width, dispH = overlay.height;
        const mapped = corners.map(p => mapVideoPointToDisplay(p.x, p.y, vidW, vidH, dispW, dispH));
        drawDetection(mapped, qrText || '');
        statusBox.textContent = `QR detected: "${qrText || '(unknown)'}"`;
        // spawn image on match - change required code below: we spawn for any QR; if you want specific text, check qrText value
        // if you only want to spawn for specific QR: if (qrText === 'poster1') { ... }
        placeSpawnImage(mapped, './new.jpg'); // use your spawn image path
      } else {
        // nothing detected this frame
        clearOverlay();
        statusBox.textContent = 'No QR detected';
      }

      requestAnimationFrame(detectLoop);
    }

    // Start camera and detector
    async function startCamera() {
      try {
        startBtn.disabled = true;
        const constraints = { video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await new Promise(r => video.onloadedmetadata = r);

        // resize overlay to match displayed video
        resizeOverlay();
        window.addEventListener('resize', resizeOverlay);

        // init detector if supported
        if ('BarcodeDetector' in window) {
          try {
            detector = new BarcodeDetector({ formats: ['qr_code'] });
          } catch (e) {
            detector = null;
          }
        }

        running = true;
        detectLoop();
        statusBox.textContent = 'Camera started — looking for QR';
      } catch (err) {
        console.error('camera start error', err);
        statusBox.textContent = 'Camera start error: ' + (err.message || err);
      } finally {
        startBtn.disabled = false;
      }
    }

    function stopCamera() {
      running = false;
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      clearOverlay();
      statusBox.textContent = 'Stopped';
    }

    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);

    // auto-resize overlay when first frame arrives
    video.addEventListener('loadeddata', resizeOverlay);
  })();
  </script>
</body>
</html>
