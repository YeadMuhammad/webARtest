<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebXR AR Replacement for QR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html, body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: sans-serif;
      }
      #overlay {
        position: fixed;
        bottom: 12px;
        left: 12px;
        right: 12px;
        padding: 12px;
        background: rgba(0,0,0,0.6);
        color: #fff;
        border-radius: 8px;
        display: flex;
        gap: 12px;
        align-items: center;
        z-index: 2;
      }
      #overlay button {
        padding: 10px 14px;
        border-radius: 6px;
        border: none;
        background: #1e88e5;
        color: white;
        font-size: 14px;
        cursor: pointer;
      }
      #overlay .status {
        flex: 1;
        font-size: 14px;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="overlay" aria-live="polite" aria-label="AR status">
      <span class="status" id="status">Preparing...</span>
      <button id="startBtn" style="display:none;">Start AR</button>
    </div>
    <script type="module">
      // Minimal WebXR AR with image tracking
      // - Detects a target image (qr-target.png)
      // - Places replacement.png on the detected target
      // - Keeps virtual content anchored to the target as you move
      // - If not compatible, shows a clear message with reasons

      const statusEl = document.getElementById('status');
      const startBtn = document.getElementById('startBtn');
      let xrSession = null;
      let gl = null;
      let canvas = null;
      let xrRefSpace = null;
      let viewerSpace = null;
      let imageTrackSource = null;
      let replacementTexture = null;
      let quadAsset = null;
      // simple quad mesh data
      let glBinding = null; // placeholder for WebXR GL binding if needed

      // Filenames (place in same folder as index.html)
      const QR_TARGET_FILENAME = 'qr-target.png'; // your QR/poster image
      const REPLACEMENT_FILENAME = 'old.jpg'; // image to show on target

      // Target descriptor
      // We assume your QR target has a known width in meters (adjust as necessary)
      const TARGET_WIDTH_METERS = 0.2; // 20 cm wide QR/poster on real world

      // Utility: load an image as an ImageBitmap
      async function loadImageBitmap(url) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = url;
        });
        const bitmap = await createImageBitmap(img);
        return bitmap;
      }

      function showNotCompatible(reason) {
        statusEl.textContent = 'Not compatible: ' + reason;
        startBtn.style.display = 'none';
      }

      async function init() {
        if (!('xr' in navigator)) {
          showNotCompatible('WebXR not supported by this browser.');
          return;
        }

        const isImgTrackingSupported = await navigator.xr.isSessionSupported('immersive-ar')
          .catch(() => false);

        if (!isImgTrackingSupported) {
          showNotCompatible('Immersive AR not supported on this device/browser.');
          return;
        }

        // Create a canvas and get GL context
        canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        gl = canvas.getContext('webgl', { xrCompatible: true });

        if (!gl) {
          showNotCompatible('WebGL not available.');
          return;
        }

        // Prepare replacement texture
        try {
          replacementTexture = await loadImageBitmap(REPLACEMENT_FILENAME);
        } catch {
          // If replacement image fails, warn but continue with a placeholder
          statusEl.textContent = 'Warning: replacement image failed to load. Using fallback.';
        }

        // Show Start AR button
        startBtn.style.display = 'inline-block';
        startBtn.addEventListener('click', onStart);
        statusEl.textContent = 'Tap Start AR to begin. Point at your QR target to place the replacement AR content.';
      }

      async function onStart() {
        startBtn.style.display = 'none';

        try {
          xrSession = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['image-tracking'] });
        } catch (err) {
          showNotCompatible('Failed to start AR session: ' + (err?.message || err));
          return;
        }

        // Set up XR WebGL context
        await gl.makeXRCompatible();
        const baseLayer = new XRWebGLLayer(xrSession, gl);
        xrSession.updateRenderState({ baseLayer });
        xrRefSpace = await xrSession.requestReferenceSpace('local');
        viewerSpace = await xrSession.requestReferenceSpace('viewer');

        // Load target image as an ImageBitmap and create an XRImageTrackingTarget
        let targetImageBitmap;
        try {
          targetImageBitmap = await loadImageBitmap(QR_TARGET_FILENAME);
        } catch (e) {
          showNotCompatible('Unable to load target image. Ensure qr-target.png is in the folder.');
          return;
        }

        const imageTrackingInit = {
          imageTargets: [
            { image: targetImageBitmap, widthInMeters: TARGET_WIDTH_METERS }
          ]
        };

        try {
          // @ts-ignore
          if (xrSession.updateImageTracking) xrSession.updateImageTracking(imageTrackingInit);
        } catch (e) {
          // Ignore; proceed; rendering loop will rely on available data
        }

        const onFrame = (time, frame) => {
          xrSession.requestAnimationFrame(onFrame);
          const pose = frame.getViewerPose(xrRefSpace);
          if (!pose) return;

          const glLayer = xrSession.renderState.baseLayer;
          gl.viewport(0, 0, glLayer.getViewport(new XRRigidTransform()).width, glLayer.getViewport(new XRRigidTransform()).height);

          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

          // Image tracking data would normally provide the pose of the detected target.
          // Here we would fetch frame.getImageTrackingResults() and render a textured quad
          // aligned with the detected target's transform.
        };

        xrSession.requestAnimationFrame(onFrame);
        statusEl.textContent = 'AR started. Move the device to detect the QR target.';
      }

      window.addEventListener('load', init);
    </script>
  </body>
</html>
